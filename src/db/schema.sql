-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Create tables
create table if not exists public.tasks (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  title text not null,
  description text,
  is_completed boolean default false,
  due_date timestamp with time zone,
  priority text check (priority in ('low', 'medium', 'high')),
  category text,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.pomodoro_sessions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  started_at timestamp with time zone not null,
  ended_at timestamp with time zone,
  duration integer not null, -- em minutos
  task_id bigint references public.tasks(id),
  was_completed boolean default false,
  interruption_count integer default 0,
  notes text,
  created_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.wellbeing_entries (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  mood text check (mood in ('great', 'good', 'okay', 'bad', 'awful')),
  energy_level integer check (energy_level between 1 and 5),
  focus_level integer check (focus_level between 1 and 5),
  anxiety_level integer check (anxiety_level between 1 and 5),
  sleep_hours numeric,
  meditation_minutes integer,
  exercise_minutes integer,
  notes text,
  created_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.diary_entries (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  content text not null,
  mood text check (mood in ('great', 'good', 'okay', 'bad', 'awful')),
  tags text[],
  is_private boolean default true,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.challenges (
  id bigint generated by default as identity primary key,
  title text not null,
  description text not null,
  points integer not null,
  type text check (type in ('daily', 'weekly', 'achievement')) not null,
  requirements jsonb not null,
  is_active boolean default true,
  start_date timestamp with time zone,
  end_date timestamp with time zone,
  created_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.achievements (
  id bigint generated by default as identity primary key,
  title text not null,
  description text not null,
  icon text not null,
  points integer not null,
  requirements jsonb not null,
  created_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.user_achievements (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  achievement_id bigint references public.achievements(id) not null,
  progress integer default 0,
  completed boolean default false,
  completed_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  unique(user_id, achievement_id)
);

create table if not exists public.ai_conversations (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  messages jsonb not null,
  title text,
  context text,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.user_profiles (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references auth.users(id) not null unique,
  display_name text,
  avatar_url text,
  preferences jsonb default '{
    "theme": "system",
    "notifications": {
      "pomodoro": true,
      "tasks": true,
      "challenges": true,
      "wellbeing": true
    },
    "pomodoro_settings": {
      "work_duration": 25,
      "break_duration": 5,
      "long_break_duration": 15,
      "sessions_until_long_break": 4
    }
  }'::jsonb not null,
  points integer default 0,
  level integer default 1,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null
);

create table if not exists public.daily_stats (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  date date not null,
  completed_tasks integer default 0,
  completed_pomodoros integer default 0,
  total_focus_time integer default 0, -- em minutos
  interruptions integer default 0,
  mood_average numeric,
  focus_average numeric,
  points_earned integer default 0,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null,
  unique(user_id, date)
);

create table if not exists public.weekly_goals (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users(id) not null,
  title text not null,
  description text,
  target integer not null,
  current integer default 0,
  type text check (type in ('pomodoros', 'tasks', 'meditation', 'exercise', 'custom')) not null,
  start_date timestamp with time zone not null,
  end_date timestamp with time zone not null,
  completed boolean default false,
  completed_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc', now()) not null,
  updated_at timestamp with time zone default timezone('utc', now()) not null
);

-- Criar índices
create index if not exists tasks_user_id_idx on public.tasks(user_id);
create index if not exists tasks_created_at_idx on public.tasks(created_at);
create index if not exists tasks_due_date_idx on public.tasks(due_date);

create index if not exists pomodoro_sessions_user_id_idx on public.pomodoro_sessions(user_id);
create index if not exists pomodoro_sessions_started_at_idx on public.pomodoro_sessions(started_at);

create index if not exists wellbeing_entries_user_id_idx on public.wellbeing_entries(user_id);
create index if not exists wellbeing_entries_created_at_idx on public.wellbeing_entries(created_at);

create index if not exists diary_entries_user_id_idx on public.diary_entries(user_id);
create index if not exists diary_entries_created_at_idx on public.diary_entries(created_at);

create index if not exists challenges_type_idx on public.challenges(type);
create index if not exists challenges_is_active_idx on public.challenges(is_active);

create index if not exists user_achievements_user_id_idx on public.user_achievements(user_id);
create index if not exists user_achievements_achievement_id_idx on public.user_achievements(achievement_id);

create index if not exists ai_conversations_user_id_idx on public.ai_conversations(user_id);
create index if not exists ai_conversations_created_at_idx on public.ai_conversations(created_at);

create index if not exists daily_stats_user_id_date_idx on public.daily_stats(user_id, date);
create index if not exists daily_stats_date_idx on public.daily_stats(date);

create index if not exists weekly_goals_user_id_idx on public.weekly_goals(user_id);
create index if not exists weekly_goals_start_date_idx on public.weekly_goals(start_date);
create index if not exists weekly_goals_end_date_idx on public.weekly_goals(end_date);

-- Criar função trigger para updated_at
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$ language plpgsql security definer;

-- Criar triggers para updated_at
create trigger handle_tasks_updated_at
  before update on public.tasks
  for each row
  execute function public.handle_updated_at();

create trigger handle_diary_entries_updated_at
  before update on public.diary_entries
  for each row
  execute function public.handle_updated_at();

create trigger handle_ai_conversations_updated_at
  before update on public.ai_conversations
  for each row
  execute function public.handle_updated_at();

create trigger handle_user_profiles_updated_at
  before update on public.user_profiles
  for each row
  execute function public.handle_updated_at();

create trigger handle_daily_stats_updated_at
  before update on public.daily_stats
  for each row
  execute function public.handle_updated_at();

create trigger handle_weekly_goals_updated_at
  before update on public.weekly_goals
  for each row
  execute function public.handle_updated_at();

-- Configurar RLS (Row Level Security)
alter table public.tasks enable row level security;
alter table public.pomodoro_sessions enable row level security;
alter table public.wellbeing_entries enable row level security;
alter table public.diary_entries enable row level security;
alter table public.user_achievements enable row level security;
alter table public.ai_conversations enable row level security;
alter table public.user_profiles enable row level security;
alter table public.daily_stats enable row level security;
alter table public.weekly_goals enable row level security;

-- Criar políticas RLS
create policy "Usuários podem ver/modificar apenas seus próprios dados"
  on public.tasks
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas seus próprios dados"
  on public.pomodoro_sessions
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas seus próprios dados"
  on public.wellbeing_entries
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas seus próprios dados"
  on public.diary_entries
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas seus próprios conquistas"
  on public.user_achievements
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas suas próprias conversas"
  on public.ai_conversations
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas seus próprios perfis"
  on public.user_profiles
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas suas próprias estatísticas"
  on public.daily_stats
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Usuários podem ver/modificar apenas suas próprias metas"
  on public.weekly_goals
  for all
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

create policy "Desafios são públicos para leitura"
  on public.challenges
  for select
  using (true);

create policy "Conquistas são públicas para leitura"
  on public.achievements
  for select
  using (true);

-- Criar função para atualizar estatísticas diárias
create or replace function public.update_daily_stats()
returns trigger as $$
declare
  stat_record record;
begin
  -- Buscar ou criar registro de estatísticas do dia
  select into stat_record *
  from public.daily_stats
  where user_id = new.user_id
    and date = date(new.created_at at time zone 'UTC');
  
  if not found then
    insert into public.daily_stats (user_id, date)
    values (new.user_id, date(new.created_at at time zone 'UTC'))
    returning * into stat_record;
  end if;

  -- Atualizar estatísticas com base no tipo de evento
  if TG_TABLE_NAME = 'tasks' and new.is_completed = true then
    update public.daily_stats
    set completed_tasks = completed_tasks + 1,
        points_earned = points_earned + 10
    where id = stat_record.id;
  
  elsif TG_TABLE_NAME = 'pomodoro_sessions' and new.was_completed = true then
    update public.daily_stats
    set completed_pomodoros = completed_pomodoros + 1,
        total_focus_time = total_focus_time + new.duration,
        interruptions = interruptions + new.interruption_count,
        points_earned = points_earned + 25
    where id = stat_record.id;
  
  elsif TG_TABLE_NAME = 'wellbeing_entries' then
    -- Calcular média de humor e foco
    update public.daily_stats
    set mood_average = (
      select avg(
        case mood
          when 'great' then 5
          when 'good' then 4
          when 'okay' then 3
          when 'bad' then 2
          when 'awful' then 1
        end
      )
      from public.wellbeing_entries
      where user_id = new.user_id
        and date(created_at) = date(new.created_at)
    ),
    focus_average = (
      select avg(focus_level)
      from public.wellbeing_entries
      where user_id = new.user_id
        and date(created_at) = date(new.created_at)
    ),
    points_earned = points_earned + 5
    where id = stat_record.id;
  end if;

  return new;
end;
$$ language plpgsql security definer;

-- Criar triggers para atualizar estatísticas
create trigger update_stats_on_task_complete
  after insert or update of is_completed
  on public.tasks
  for each row
  when (new.is_completed = true)
  execute function public.update_daily_stats();

create trigger update_stats_on_pomodoro_complete
  after insert or update of was_completed
  on public.pomodoro_sessions
  for each row
  when (new.was_completed = true)
  execute function public.update_daily_stats();

create trigger update_stats_on_wellbeing_entry
  after insert
  on public.wellbeing_entries
  for each row
  execute function public.update_daily_stats();

-- Criar função para verificar e conceder conquistas
create or replace function public.check_achievements()
returns trigger as $$
begin
  -- Verificar conquistas baseadas em tarefas completadas
  if TG_TABLE_NAME = 'tasks' and new.is_completed = true then
    insert into public.user_achievements (user_id, achievement_id, progress, completed)
    select 
      new.user_id,
      a.id,
      count(t.*),
      count(t.*) >= (a.requirements->>'target')::int
    from public.achievements a
    left join public.tasks t
      on t.user_id = new.user_id
      and t.is_completed = true
    where a.requirements->>'type' = 'tasks'
      and not exists (
        select 1 from public.user_achievements ua
        where ua.user_id = new.user_id
          and ua.achievement_id = a.id
      )
    group by a.id
    having count(t.*) >= (a.requirements->>'target')::int;
  
  -- Verificar conquistas baseadas em pomodoros completados
  elsif TG_TABLE_NAME = 'pomodoro_sessions' and new.was_completed = true then
    insert into public.user_achievements (user_id, achievement_id, progress, completed)
    select 
      new.user_id,
      a.id,
      count(p.*),
      count(p.*) >= (a.requirements->>'target')::int
    from public.achievements a
    left join public.pomodoro_sessions p
      on p.user_id = new.user_id
      and p.was_completed = true
    where a.requirements->>'type' = 'pomodoros'
      and not exists (
        select 1 from public.user_achievements ua
        where ua.user_id = new.user_id
          and ua.achievement_id = a.id
      )
    group by a.id
    having count(p.*) >= (a.requirements->>'target')::int;
  end if;

  return new;
end;
$$ language plpgsql security definer;

-- Criar triggers para verificar conquistas
create trigger check_achievements_on_task_complete
  after insert or update of is_completed
  on public.tasks
  for each row
  when (new.is_completed = true)
  execute function public.check_achievements();

create trigger check_achievements_on_pomodoro_complete
  after insert or update of was_completed
  on public.pomodoro_sessions
  for each row
  when (new.was_completed = true)
  execute function public.check_achievements();
